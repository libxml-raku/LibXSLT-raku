use v6;
#  -- DO NOT EDIT --
# generated by: ../LibXML-p6/etc/generator.p6 --mod=LibXSLT --lib=XSLT etc/libxslt-api.xml

unit module LibXSLT::Native::Gen::xsltInternals;
# internal data structures, constants and functions:
#    Internal data structures, constants and functions used by the XSLT engine. They are not part of the API or ABI, i.e. they can change without prior notice, use carefully. 
use LibXSLT::Native::Defs :$lib, :xmlCharP;

enum xsltErrorSeverityType is export (
    XSLT_ERROR_SEVERITY_ERROR => 0,
    XSLT_ERROR_SEVERITY_WARNING => 1,
);

enum xsltOutputType is export (
    XSLT_OUTPUT_HTML => 1,
    XSLT_OUTPUT_TEXT => 2,
    XSLT_OUTPUT_XML => 0,
);

enum xsltStyleType is export (
    XSLT_FUNC_APPLYIMPORTS => 11,
    XSLT_FUNC_APPLYTEMPLATES => 13,
    XSLT_FUNC_ATTRIBUTE => 5,
    XSLT_FUNC_ATTRSET => 27,
    XSLT_FUNC_CALLTEMPLATE => 12,
    XSLT_FUNC_CHOOSE => 14,
    XSLT_FUNC_COMMENT => 6,
    XSLT_FUNC_COPY => 1,
    XSLT_FUNC_COPYOF => 8,
    XSLT_FUNC_DOCUMENT => 17,
    XSLT_FUNC_ELEMENT => 4,
    XSLT_FUNC_EXTENSION => 22,
    XSLT_FUNC_FALLBACK => 24,
    XSLT_FUNC_FOREACH => 16,
    XSLT_FUNC_IF => 15,
    XSLT_FUNC_INCLUDE => 26,
    XSLT_FUNC_LITERAL_RESULT_ELEMENT => 28,
    XSLT_FUNC_MESSAGE => 25,
    XSLT_FUNC_NUMBER => 10,
    XSLT_FUNC_OTHERWISE => 23,
    XSLT_FUNC_PARAM => 19,
    XSLT_FUNC_PI => 7,
    XSLT_FUNC_SORT => 2,
    XSLT_FUNC_TEXT => 3,
    XSLT_FUNC_UNKOWN_FORWARDS_COMPAT => 29,
    XSLT_FUNC_VALUEOF => 9,
    XSLT_FUNC_VARIABLE => 20,
    XSLT_FUNC_WHEN => 21,
    XSLT_FUNC_WITHPARAM => 18,
);

enum xsltTransformState is export (
    XSLT_STATE_ERROR => 1,
    XSLT_STATE_OK => 0,
    XSLT_STATE_STOPPED => 2,
);

class xsltCompilerCtxt is repr('CStruct') {
    has Pointer $.errorCtxt; # * used for error/warning reports; e.g. XSLT_ERROR_SEVERITY_WARNING
    has xsltErrorSeverityType $.errSeverity;
    has int32 $.warnings; # TODO: number of warnings found at compilation
    has int32 $.errors; # TODO: number of errors found at compilation
    has xmlDict $.dict;
    has xsltStylesheet $.style;
    has int32 $.simplified; # whether this is a simplified stylesheet TODO: structured/unstructured error contexts.
    has int32 $.depth; # Current depth of processing
    has xsltCompilerNodeInfo $.inode;
    has xsltCompilerNodeInfo $.inodeList;
    has xsltCompilerNodeInfo $.inodeLast;
    has xsltPointerList $.tmpList; # * The XSLT version as specified by the stylesheet's root element. *
    has int32 $.isInclude;
    has int32 $.hasForwardsCompat; # whether forwards-compatible mode was used in a parsing episode
    has int32 $.maxNodeInfos; # TEMP TODO: just for the interest
    has int32 $.maxLREs; # * In order to keep the old behaviour, applying strict rules of * the spec can be turned off. This has effect only on special * mechanisms like whitespace-stripping in the stylesheet. *
    has int32 $.strict;
    has xsltPrincipalStylesheetData $.psData;
    has xsltStyleItemUknown $.unknownItem;
    has int32 $.hasNsAliases; # Indicator if there was an xsl:namespace-alias.
    has xsltNsAlias $.nsAliases;
    has xsltVarInfo $.ivars; # Storage of local in-scope variables/params.
    has xsltVarInfo $.ivar; # topmost local variable/param.
    method xsltParseAnyXSLTElem(xmlNode $elem --> int32) is native(XSLT) {*};
    method xsltParseSequenceConstructor(xmlNode $cur) is native(XSLT) {*};
}

class xsltCompilerNodeInfo is repr('CStruct') {
    has xsltCompilerNodeInfo $.next;
    has xsltCompilerNodeInfo $.prev;
    has xmlNode $.node;
    has int32 $.depth;
    has xsltTemplate $.templ; # The owning template
    has int32 $.category; # XSLT element, LR-element or extension element
    has xsltStyleType $.type;
    has xsltElemPreComp $.item; # The compiled information The current in-scope namespaces
    has xsltNsListContainer $.inScopeNs; # The current excluded result namespaces
    has xsltPointerList $.exclResultNs; # The current extension instruction namespaces
    has xsltPointerList $.extElemNs; # The current info for literal result elements.
    has xsltStyleItemLRElementInfo $.litResElemInfo; # * Set to 1 if in-scope namespaces changed, *  or excluded result namespaces changed, *  or extension element namespaces changed. * This will trigger creation of new infos *  for literal result elements. *
    has int32 $.nsChanged;
    has int32 $.preserveWhitespace;
    has int32 $.stripWhitespace;
    has int32 $.isRoot; # whether this is the stylesheet's root node
    has int32 $.forwardsCompat; # whether forwards-compatible mode is enabled whether the content of an extension element was processed
    has int32 $.extContentHandled; # the type of the current child
    has xsltStyleType $.curChildType;
}

class xsltDecimalFormat is repr('CStruct') {
    has xsltDecimalFormat $.next; # chained list
    has xmlCharP $.name; # Used for interpretation of pattern
    has xmlCharP $.digit;
    has xmlCharP $.patternSeparator; # May appear in result
    has xmlCharP $.minusSign;
    has xmlCharP $.infinity;
    has xmlCharP $.noNumber; # Not-a-number Used for interpretation of pattern and may appear in result
    has xmlCharP $.decimalPoint;
    has xmlCharP $.grouping;
    has xmlCharP $.percent;
    has xmlCharP $.permille;
    has xmlCharP $.zeroDigit;
    has xmlCharP $.nsUri;
    method xsltFormatNumberConversion(xmlCharP $format, num64 $number, xmlChar ** $result --> xmlXPathError) is native(XSLT) {*};
}

class xsltDocument is repr('CStruct') {
    has xsltDocument $.next; # documents are kept in a chained list
    has int32 $.main; # is this the main document
    has xmlDoc $.doc; # the parsed document
    has Pointer $.keys; # key tables storage
    has xsltDocument $.includes; # subsidiary includes
    has int32 $.preproc; # pre-processing already done
    has int32 $.nbKeysComputed;
    method xsltFreeDocumentKeys() is native(XSLT) {*};
}

class xsltEffectiveNs is repr('CStruct') {
    has xsltEffectiveNs $.nextInStore; # storage next
    has xsltEffectiveNs $.next; # next item in the list
    has xmlCharP $.prefix;
    has xmlCharP $.nsName; # * Indicates if eclared on the literal result element; dunno if really * needed. *
    has int32 $.holdByElem;
}

class xsltElemPreComp is repr('CStruct') {
    has xsltElemPreComp $.next; # next item in the global chained list held by xsltStylesheet.
    has xsltStyleType $.type; # type of the element
    has xsltTransformFunction $.func; # handling function
    has xmlNode $.inst; # the node in the stylesheet's tree corresponding to this item end of common part
    has xsltElemPreCompDeallocator $.free; # the deallocator
    method xsltInit(xsltStylesheet $style, xmlNode $inst, xsltTransformFunction $function, xsltElemPreCompDeallocator $freeFunc) is native(XSLT) is symbol('xsltInitElemPreComp') {*};
}

class xsltKeyDef is repr('CStruct') {
    has xsltKeyDef $.next;
    has xmlNode $.inst;
    has xmlCharP $.name;
    has xmlCharP $.nameURI;
    has xmlCharP $.match;
    has xmlCharP $.use;
    has xmlXPathCompExpr $.comp;
    has xmlXPathCompExpr $.usecomp;
    has xmlNsPtr * $.nsList; # the namespaces in scope
    has int32 $.nsNr; # the number of namespaces in scope
}

class xsltKeyTable is repr('CStruct') {
    has xsltKeyTable $.next;
    has xmlCharP $.name;
    has xmlCharP $.nameURI;
    has xmlHashTable $.keys;
}

class xsltNsAlias is repr('CStruct') {
    has xsltNsAlias $.next; # next in the list
    has xmlNs $.literalNs;
    has xmlNs $.targetNs;
    has xmlDoc $.docOfTargetNs;
}

class xsltNsList is repr('CStruct') {
    has xsltNsList $.next; # next in the list
    has xmlNs $.ns;
}

class xsltNsListContainer is repr('CStruct') {
    has xmlNsPtr * $.list;
    has int32 $.totalNumber;
    has int32 $.xpathNumber;
}

class xsltNsMap is repr('CStruct') {
    has xsltNsMap $.next; # next in the list
    has xmlDoc $.doc;
    has xmlNode $.elem; # the element holding the ns-decl
    has xmlNs $.ns; # the xmlNs structure holding the XML namespace name
    has xmlCharP $.origNsName; # the original XML namespace name
    has xmlCharP $.newNsName; # the mapped XML namespace name
    method xsltRestoreDocumentNamespaces(xmlDoc $doc --> int32) is native(XSLT) {*};
}

class xsltPointerList is repr('CStruct') {
    has void ** $.items;
    has int32 $.number;
    has int32 $.size;

    sub xsltPointerListCreate(int32 $initialSize --> xsltPointerList) is native(XSLT) is export {*};

    method xsltPointerListAddSize(Pointer $item, int32 $initialSize --> int32) is native(XSLT) {*};
    method xsltPointerListClear() is native(XSLT) {*};
    method xsltPointerListFree() is native(XSLT) {*};
}

class xsltPrincipalStylesheetData is repr('CStruct') {
    has xmlDict $.namespaceDict; # * Global list of in-scope namespaces. *
    has xsltPointerList $.inScopeNamespaces; # * Global list of information for [xsl:]excluded-result-prefixes. *
    has xsltPointerList $.exclResultNamespaces; # * Global list of information for [xsl:]extension-element-prefixes. *
    has xsltPointerList $.extElemNamespaces;
    has xsltEffectiveNs $.effectiveNs; # * Namespace name map to get rid of string comparison of namespace names. *
    has xsltNsMap $.nsMap;
}

class xsltRuntimeExtra is repr('CStruct') {
    has Pointer $.info; # pointer to the extra data
    has xmlFreeFunc $.deallocate; # pointer to the deallocation routine
}

class xsltStackElem is repr('CStruct') {
    has xsltStackElem $.next; # chained list
    has xsltStylePreComp $.comp; # the compiled form
    has int32 $.computed; # was the evaluation done
    has xmlCharP $.name; # the local part of the name QName
    has xmlCharP $.nameURI; # the URI part of the name QName
    has xmlCharP $.select; # the eval string
    has xmlNode $.tree; # the sequence constructor if no eval string or the location
    has xmlXPathObject $.value; # The value if computed
    has xmlDoc $.fragment; # The Result Tree Fragments (needed for XSLT 1.0) which are bound to the variable's lifetime.
    has int32 $.level; # the depth in the tree; -1 if persistent (e.g. a given xsl:with-param)
    has xsltTransformContext $.context; # The transformation context; needed to cache the variables
    has int32 $.flags;
    method xsltFreeStackElemList() is native(XSLT) {*};
}

class xsltStyleBasicEmptyItem is repr('CPointer') {
}

class xsltStyleBasicExpressionItem is repr('CStruct') {
    has xmlCharP $.select; # TODO: Change this to "expression".
    has xmlXPathCompExpr $.comp; # TODO: Change this to compExpr.
}

class xsltStyleBasicItemVariable is repr('CStruct') {
    has xmlCharP $.select;
    has xmlXPathCompExpr $.comp;
    has xmlCharP $.name;
    has int32 $.has_name;
    has xmlCharP $.ns;
    has int32 $.has_ns;
}

class xsltStyleItemApplyTemplates is repr('CStruct') {
    has xmlCharP $.mode; # apply-templates
    has xmlCharP $.modeURI; # apply-templates
    has xmlCharP $.select; # sort, copy-of, value-of, apply-templates
    has xmlXPathCompExpr $.comp; # a precompiled XPath expression TODO: with-params
}

class xsltStyleItemAttribute is repr('CStruct') {
    has xmlCharP $.name;
    has int32 $.has_name;
    has xmlCharP $.ns;
    has xmlCharP $.nsPrefix;
    has int32 $.has_ns;
}

class xsltStyleItemCallTemplate is repr('CStruct') {
    has xsltTemplate $.templ; # call-template
    has xmlCharP $.name; # element, attribute, pi
    has int32 $.has_name; # element, attribute, pi
    has xmlCharP $.ns; # element
    has int32 $.has_ns; # element TODO: with-params
}

class xsltStyleItemCopy is repr('CStruct') {
    has xmlCharP $.use; # copy, element
    has int32 $.has_use; # copy, element
}

class xsltStyleItemDocument is repr('CStruct') {
    has int32 $.ver11; # assigned: in xsltDocumentComp; read: nowhere; TODO: Check if we need.
    has xmlCharP $.filename; # document URL
    has int32 $.has_filename;
}

class xsltStyleItemElement is repr('CStruct') {
    has xmlCharP $.use;
    has int32 $.has_use;
    has xmlCharP $.name;
    has int32 $.has_name;
    has xmlCharP $.ns;
    has xmlCharP $.nsPrefix;
    has int32 $.has_ns;
}

class xsltStyleItemExtElement is repr('CStruct') {
    has xsltElemPreComp $.item;
}

class xsltStyleItemIf is repr('CStruct') {
    has xmlCharP $.test; # if
    has xmlXPathCompExpr $.comp; # a precompiled XPath expression
}

class xsltStyleItemInclude is repr('CStruct') {
    has xsltDocument $.include;
}

class xsltStyleItemLRElementInfo is repr('CStruct') {
    has xsltEffectiveNs $.effectiveNs;
}

class xsltStyleItemMessage is repr('CStruct') {
    has int32 $.terminate;
}

class xsltStyleItemNumber is repr('CStruct') {
    has xsltNumberData $.numdata; # number
}

class xsltStyleItemOtherwise is repr('CPointer') {
}

class xsltStyleItemPI is repr('CStruct') {
    has xmlCharP $.name;
    has int32 $.has_name;
}

class xsltStyleItemParam is repr('CStruct') {
    has xmlCharP $.select;
    has xmlXPathCompExpr $.comp;
    has xmlCharP $.name;
    has int32 $.has_name;
    has xmlCharP $.ns;
    has int32 $.has_ns;
}

class xsltStyleItemSort is repr('CStruct') {
    has xmlCharP $.stype; # sort
    has int32 $.has_stype; # sort
    has int32 $.number; # sort
    has xmlCharP $.order; # sort
    has int32 $.has_order; # sort
    has int32 $.descending; # sort
    has xmlCharP $.lang; # sort
    has int32 $.has_lang; # sort
    has xsltLocale $.locale; # sort
    has xmlCharP $.case_order; # sort
    has int32 $.lower_first; # sort
    has xmlCharP $.use;
    has int32 $.has_use;
    has xmlCharP $.select; # sort, copy-of, value-of, apply-templates
    has xmlXPathCompExpr $.comp; # a precompiled XPath expression
}

class xsltStyleItemText is repr('CStruct') {
    has int32 $.noescape; # text
}

class xsltStyleItemUknown is repr('CPointer') {
}

class xsltStyleItemValueOf is repr('CStruct') {
    has xmlCharP $.select;
    has xmlXPathCompExpr $.comp; # a precompiled XPath expression
    has int32 $.noescape;
}

class xsltStyleItemWhen is repr('CStruct') {
    has xmlCharP $.test;
    has xmlXPathCompExpr $.comp;
}

class xsltStylePreComp is repr('CStruct') {
    has xsltElemPreComp $.next; # chained list
    has xsltStyleType $.type; # type of the element
    has xsltTransformFunction $.func; # handling function
    has xmlNode $.inst; # * Pre computed values. *
    has xmlCharP $.stype; # sort
    has int32 $.has_stype; # sort
    has int32 $.number; # sort
    has xmlCharP $.order; # sort
    has int32 $.has_order; # sort
    has int32 $.descending; # sort
    has xmlCharP $.lang; # sort
    has int32 $.has_lang; # sort
    has xsltLocale $.locale; # sort
    has xmlCharP $.case_order; # sort
    has int32 $.lower_first; # sort
    has xmlCharP $.use; # copy, element
    has int32 $.has_use; # copy, element
    has int32 $.noescape; # text
    has xmlCharP $.name; # element, attribute, pi
    has int32 $.has_name; # element, attribute, pi
    has xmlCharP $.ns; # element
    has int32 $.has_ns; # element
    has xmlCharP $.mode; # apply-templates
    has xmlCharP $.modeURI; # apply-templates
    has xmlCharP $.test; # if
    has xsltTemplate $.templ; # call-template
    has xmlCharP $.select; # sort, copy-of, value-of, apply-templates
    has int32 $.ver11; # document
    has xmlCharP $.filename; # document URL
    has int32 $.has_filename; # document
    has xsltNumberData $.numdata; # number
    has xmlXPathCompExpr $.comp; # a precompiled XPath expression
    has xmlNsPtr * $.nsList; # the namespaces in scope
    has int32 $.nsNr; # the number of namespaces in scope
}

class xsltStylesheet is repr('CStruct') {
    has xsltStylesheet $.parent;
    has xsltStylesheet $.next;
    has xsltStylesheet $.imports;
    has xsltDocument $.docList; # * General data on the style sheet document. *
    has xmlDoc $.doc; # the parsed XML stylesheet
    has xmlHashTable $.stripSpaces; # the hash table of the strip-space and preserve space elements
    has int32 $.stripAll; # strip-space * (1) preserve-space * (-1)
    has xmlHashTable $.cdataSection; # * Global variable or parameters. *
    has xsltStackElem $.variables; # * Template descriptions. *
    has xsltTemplate $.templates; # the ordered list of templates
    has Pointer $.templatesHash; # hash table or wherever compiled templates information is stored
    has Pointer $.rootMatch; # template based on /
    has Pointer $.keyMatch; # template based on key()
    has Pointer $.elemMatch; # template based on *
    has Pointer $.attrMatch; # template based on @*
    has Pointer $.parentMatch; # template based on ..
    has Pointer $.textMatch; # template based on text()
    has Pointer $.piMatch; # template based on processing-instruction()
    has Pointer $.commentMatch; # * Namespace aliases. * NOTE: Not used in the refactored code. *
    has xmlHashTable $.nsAliases; # * Attribute sets. *
    has xmlHashTable $.attributeSets; # * Namespaces. * TODO: Eliminate this. *
    has xmlHashTable $.nsHash; # the set of namespaces in use: ATTENTION: This is used for execution of XPath expressions; unfortunately it restricts the stylesheet to have distinct prefixes. TODO: We need to get rid of this. *
    has Pointer $.nsDefs; # * Key definitions. *
    has Pointer $.keys; # * Output related stuff. *
    has xmlCharP $.method; # the output method
    has xmlCharP $.methodURI; # associated namespace if any
    has xmlCharP $.version; # version string
    has xmlCharP $.encoding; # encoding string
    has int32 $.omitXmlDeclaration; # * Number formatting. *
    has xsltDecimalFormat $.decimalFormat;
    has int32 $.standalone; # standalone = "yes" | "no"
    has xmlCharP $.doctypePublic; # doctype-public string
    has xmlCharP $.doctypeSystem; # doctype-system string
    has int32 $.indent; # should output being indented
    has xmlCharP $.mediaType; # * Precomputed blocks. *
    has xsltElemPreComp $.preComps; # list of precomputed blocks
    has int32 $.warnings; # number of warnings found at compilation
    has int32 $.errors; # number of errors found at compilation
    has xmlCharP $.exclPrefix; # last excluded prefixes
    has xmlChar ** $.exclPrefixTab; # array of excluded prefixes
    has int32 $.exclPrefixNr; # number of excluded prefixes in scope
    has int32 $.exclPrefixMax; # size of the array
    has Pointer $._private; # * Extensions. *
    has xmlHashTable $.extInfos; # the extension data
    has int32 $.extrasNr; # * For keeping track of nested includes *
    has xsltDocument $.includes; # * dictionary: shared between stylesheet, context and documents. *
    has xmlDict $.dict; # * precompiled attribute value templates. *
    has Pointer $.attVTs; # * if namespace-alias has an alias for the default stylesheet prefix * NOTE: Not used in the refactored code. *
    has xmlCharP $.defaultAlias; # * bypass pre-processing (already done) (used in imports) *
    has int32 $.nopreproc; # * all document text strings were internalized *
    has int32 $.internalized; # * Literal Result Element as Stylesheet c.f. section 2.3 *
    has int32 $.literal_result; # * The principal stylesheet *
    has xsltStylesheet $.principal; # * Compilation context used during compile-time. *
    has xsltCompilerCtxt $.compCtxt; # TODO: Change this to (void *).
    has xsltPrincipalStylesheetData $.principalData; # * Forwards-compatible processing *
    has int32 $.forwards_compatible;
    has xmlHashTable $.namedTemplates; # hash table of named templates
    has xmlXPathContext $.xpathCtxt;

    sub xsltLoadStylesheetPI(xmlDoc $doc --> xsltStylesheet) is native(XSLT) is export {*};
    sub xsltNewStylesheet( --> xsltStylesheet) is native(XSLT) is export {*};
    sub xsltParseStylesheetDoc(xmlDoc $doc --> xsltStylesheet) is native(XSLT) is export {*};
    sub xsltParseStylesheetFile(xmlCharP $filename --> xsltStylesheet) is native(XSLT) is export {*};
    sub xsltParseStylesheetImportedDoc(xmlDoc $doc, xsltStylesheet $parentStyle --> xsltStylesheet) is native(XSLT) is export {*};

    method xsltAddKey(xmlCharP $name, xmlCharP $nameURI, xmlCharP $match, xmlCharP $use, xmlNode $inst --> int32) is native(XSLT) {*};
    method xsltAddTemplate(xsltTemplate $cur, xmlCharP $mode, xmlCharP $modeURI --> int32) is native(XSLT) {*};
    method xsltAllocateExtra( --> int32) is native(XSLT) {*};
    method xsltApply(xmlDoc $doc, const char ** $params --> xmlDoc) is native(XSLT) is symbol('xsltApplyStylesheet') {*};
    method xsltApplyStylesheetUser(xmlDoc $doc, const char ** $params, Str $output, FILE * $profile, xsltTransformContext $userCtxt --> xmlDoc) is native(XSLT) {*};
    method xsltCheckExtPrefix(xmlCharP $URI --> int32) is native(XSLT) {*};
    method xsltCheckExtURI(xmlCharP $URI --> int32) is native(XSLT) {*};
    method xsltCleanupTemplates() is native(XSLT) {*};
    method xsltCompileAttr(xmlAttr $attr) is native(XSLT) {*};
    method xsltDecimalFormatGetByName(xmlCharP $name --> xsltDecimalFormat) is native(XSLT) {*};
    method xsltDecimalFormatGetByQName(xmlCharP $nsUri, xmlCharP $name --> xsltDecimalFormat) is native(XSLT) {*};
    method xsltDocumentComp(xmlNode $inst, xsltTransformFunction $function --> xsltElemPreComp) is native(XSLT) {*};
    method xsltEvalStaticAttrValueTemplate(xmlNode $inst, xmlCharP $name, xmlCharP $ns, Pointer[int32] $found --> xmlCharP) is native(XSLT) {*};
    method xsltFreeAttributeSetsHashes() is native(XSLT) {*};
    method xsltFreeExts() is native(XSLT) {*};
    method xsltFreeKeys() is native(XSLT) {*};
    method xsltFreeNamespaceAliasHashes() is native(XSLT) {*};
    method xsltFreeStyleDocuments() is native(XSLT) {*};
    method xsltFreeStylePreComps() is native(XSLT) {*};
    method xsltFree() is native(XSLT) is symbol('xsltFreeStylesheet') {*};
    method xsltFreeTemplateHashes() is native(XSLT) {*};
    method xsltGetCNsProp(xmlNode $node, xmlCharP $name, xmlCharP $nameSpace --> xmlCharP) is native(XSLT) {*};
    method xsltGetExtInfo(xmlCharP $URI --> xmlHashTable) is native(XSLT) {*};
    method xsltGetQNameURI2(xmlNode $node, const xmlChar ** $name --> xmlCharP) is native(XSLT) {*};
    method xsltLoadStyleDocument(xmlCharP $URI --> xsltDocument) is native(XSLT) {*};
    method xsltNamespaceAlias(xmlNode $node) is native(XSLT) {*};
    method xsltNewElemPreComp(xmlNode $inst, xsltTransformFunction $function --> xsltElemPreComp) is native(XSLT) {*};
    method xsltNewStyleDocument(xmlDoc $doc --> xsltDocument) is native(XSLT) {*};
    method xsltNewTransformContext(xmlDoc $doc --> xsltTransformContext) is native(XSLT) {*};
    method xsltNextImport( --> xsltStylesheet) is native(XSLT) {*};
    method xsltParseGlobalParam(xmlNode $cur) is native(XSLT) {*};
    method xsltParseGlobalVariable(xmlNode $cur) is native(XSLT) {*};
    method xsltParseStylesheetAttributeSet(xmlNode $cur) is native(XSLT) {*};
    method xsltParseStylesheetImport(xmlNode $cur --> int32) is native(XSLT) {*};
    method xsltParseStylesheetInclude(xmlNode $cur --> int32) is native(XSLT) {*};
    method xsltParseStylesheetOutput(xmlNode $cur) is native(XSLT) {*};
    method xsltParseStylesheetProcess(xmlDoc $doc --> xsltStylesheet) is native(XSLT) {*};
    method xsltParseStylesheetUser(xmlDoc $doc --> int32) is native(XSLT) {*};
    method xsltParseTemplateContent(xmlNode $templ) is native(XSLT) {*};
    method xsltPreComputeExtModuleElement(xmlNode $inst --> xsltElemPreComp) is native(XSLT) {*};
    method xsltProfile(xmlDoc $doc, const char ** $params, FILE * $output --> xmlDoc) is native(XSLT) is symbol('xsltProfileStylesheet') {*};
    method xsltRegisterExtPrefix(xmlCharP $prefix, xmlCharP $URI --> int32) is native(XSLT) {*};
    method xsltResolveStylesheetAttributeSet() is native(XSLT) {*};
    method xsltRun(xmlDoc $doc, const char ** $params, Str $output, xmlSAXHandler $SAX, xmlOutputBuffer $IObuf --> int32) is native(XSLT) is symbol('xsltRunStylesheet') {*};
    method xsltRunStylesheetUser(xmlDoc $doc, const char ** $params, Str $output, xmlSAXHandler $SAX, xmlOutputBuffer $IObuf, FILE * $profile, xsltTransformContext $userCtxt --> int32) is native(XSLT) {*};
    method xsltShutdownExts() is native(XSLT) {*};
    method xsltStyleGetExtData(xmlCharP $URI --> Pointer) is native(XSLT) {*};
    method xsltStylePreCompute(xmlNode $inst) is native(XSLT) {*};
    method xsltStyleStylesheetLevelGetExtData(xmlCharP $URI --> Pointer) is native(XSLT) {*};
    method xsltXPathCompile(xmlCharP $str --> xmlXPathCompExpr) is native(XSLT) {*};
    method xsltXPathCompileFlags(xmlCharP $str, int32 $flags --> xmlXPathCompExpr) is native(XSLT) {*};
}

class xsltTemplate is repr('CStruct') {
    has xsltTemplate $.next; # chained list sorted by priority
    has xsltStylesheet $.style; # the containing stylesheet
    has xmlCharP $.match; # the matching string
    has float $.priority; # as given from the stylesheet, not computed
    has xmlCharP $.name; # the local part of the name QName
    has xmlCharP $.nameURI; # the URI part of the name QName
    has xmlCharP $.mode; # the local part of the mode QName
    has xmlCharP $.modeURI; # the URI part of the mode QName
    has xmlNode $.content; # the template replacement value
    has xmlNode $.elem; # * TODO: @inheritedNsNr and @inheritedNs won't be used in the *  refactored code. *
    has int32 $.inheritedNsNr; # number of inherited namespaces
    has xmlNsPtr * $.inheritedNs; # inherited non-excluded namespaces Profiling information
    has int32 $.nbCalls; # the number of time the template was called
    has ulong $.time; # the time spent in this template
    has Pointer $.params; # xsl:param instructions
    has int32 $.templNr; # Nb of templates in the stack
    has int32 $.templMax; # Size of the templtes stack
    has xsltTemplatePtr * $.templCalledTab; # templates called
    has Pointer[int32] $.templCountTab; # .. and how often
    method xslAddCall(xmlNode $source --> int32) is native(XSLT) {*};
}

class xsltTransformCache is repr('CStruct') {
    has xmlDoc $.RVT;
    has int32 $.nbRVT;
    has xsltStackElem $.stackItems;
    has int32 $.nbStackItems;
    has int32 $.dbgCachedRVTs;
    has int32 $.dbgReusedRVTs;
    has int32 $.dbgCachedVars;
    has int32 $.dbgReusedVars;
}

class xsltTransformContext is repr('CStruct') {
    has xsltStylesheet $.style; # the stylesheet used
    has xsltOutputType $.type; # the type of output
    has xsltTemplate $.templ; # the current template
    has int32 $.templNr; # Nb of templates in the stack
    has int32 $.templMax; # Size of the templtes stack
    has xsltTemplatePtr * $.templTab; # the template stack
    has xsltStackElem $.vars; # the current variable list
    has int32 $.varsNr; # Nb of variable list in the stack
    has int32 $.varsMax; # Size of the variable list stack
    has xsltStackElemPtr * $.varsTab; # the variable list stack
    has int32 $.varsBase; # * Extensions *
    has xmlHashTable $.extFunctions; # the extension functions
    has xmlHashTable $.extElements; # the extension elements
    has xmlHashTable $.extInfos; # the extension data
    has xmlCharP $.mode; # the current mode
    has xmlCharP $.modeURI; # the current mode URI
    has xsltDocument $.docList; # the document list
    has xsltDocument $.document; # the current source document; can be NULL if an RTF
    has xmlNode $.node; # the current node being processed
    has xmlNodeSet $.nodeList; # the current node list xmlNodePtr current;   the node
    has xmlDoc $.output; # the resulting document
    has xmlNode $.insert; # the insertion node
    has xmlXPathContext $.xpathCtxt; # the XPath context
    has xsltTransformState $.state; # * Global variables *
    has xmlHashTable $.globalVars; # the global variables and params
    has xmlNode $.inst; # the instruction in the stylesheet
    has int32 $.xinclude; # should XInclude be processed
    has Str $.outputFile; # the output URI if known
    has int32 $.profile; # is this run profiled
    has long $.prof; # the current profiled value
    has int32 $.profNr; # Nb of templates in the stack
    has int32 $.profMax; # Size of the templtaes stack
    has long * $.profTab; # the profile template stack
    has Pointer $._private; # user defined data
    has int32 $.extrasNr; # the number of extras used
    has int32 $.extrasMax; # the number of extras allocated
    has xsltRuntimeExtra $.extras; # extra per runtime information
    has xsltDocument $.styleList; # the stylesheet docs list
    has Pointer $.sec; # the security preferences if any
    has xmlGenericErrorFunc $.error; # a specific error handler
    has Pointer $.errctx; # context for the error handler
    has xsltSortFunc $.sortfunc; # * handling of temporary Result Value Tree * (XSLT 1.0 term: "Result Tree Fragment") *
    has xmlDoc $.tmpRVT; # list of RVT without persistance
    has xmlDoc $.persistRVT; # list of persistant RVTs
    has int32 $.ctxtflags; # * Speed optimization when coalescing text nodes *
    has xmlCharP $.lasttext; # last text node content
    has int32 $.lasttsize; # last text node size
    has int32 $.lasttuse; # * Per Context Debugging *
    has int32 $.debugStatus; # the context level debug status
    has unsigned long * $.traceCode; # pointer to the variable holding the mask
    has int32 $.parserOptions; # * dictionary: shared between stylesheet, context and documents. *
    has xmlDict $.dict;
    has xmlDoc $.tmpDoc; # * all document text strings are internalized *
    has int32 $.internalized;
    has int32 $.nbKeys;
    has int32 $.hasTemplKeyPatterns;
    has xsltTemplate $.currentTemplateRule; # the Current Template Rule
    has xmlNode $.initialContextNode;
    has xmlDoc $.initialContextDoc;
    has xsltTransformCache $.cache;
    has Pointer $.contextVariable; # the current variable item
    has xmlDoc $.localRVT; # list of local tree fragments; will be freed when the instruction which created the fragment exits
    has xmlDoc $.localRVTBase; # Obsolete
    has int32 $.keyInitLevel; # Needed to catch recursive keys issues
    has int32 $.depth; # Needed to catch recursions
    has int32 $.maxTemplateDepth;
    has int32 $.maxTemplateVars;
    has ulong $.opLimit;
    has ulong $.opCount;

    sub xsltXPathGetTransformContext(xmlXPathParserContext $ctxt --> xsltTransformContext) is native(XSLT) is export {*};

    method xsltAddStackElemList(xsltStackElem $elems --> int32) is native(XSLT) {*};
    method xsltAllocateExtraCtxt( --> int32) is native(XSLT) {*};
    method xsltApplyAttributeSet(xmlNode $node, xmlNode $inst, xmlCharP $attrSets) is native(XSLT) {*};
    method xsltApplyImports(xmlNode $contextNode, xmlNode $inst, xsltElemPreComp $comp) is native(XSLT) {*};
    method xsltApplyOneTemplate(xmlNode $contextNode, xmlNode $list, xsltTemplate $templ, xsltStackElem $params) is native(XSLT) {*};
    method xsltApplyStripSpaces(xmlNode $node) is native(XSLT) {*};
    method xsltApplyTemplates(xmlNode $node, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltAttrListTemplateProcess(xmlNode $target, xmlAttr $attrs --> xmlAttr) is native(XSLT) {*};
    method xsltAttrTemplateProcess(xmlNode $target, xmlAttr $attr --> xmlAttr) is native(XSLT) {*};
    method xsltAttrTemplateValueProcess(xmlCharP $str --> xmlCharP) is native(XSLT) {*};
    method xsltAttrTemplateValueProcessNode(xmlCharP $str, xmlNode $inst --> xmlCharP) is native(XSLT) {*};
    method xsltAttribute(xmlNode $contextNode, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltCallTemplate(xmlNode $node, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltChoose(xmlNode $contextNode, xmlNode $inst, xsltElemPreComp $comp) is native(XSLT) {*};
    method xsltComment(xmlNode $node, xmlNode $inst, xsltElemPreComp $comp) is native(XSLT) {*};
    method xsltComputeSortResult(xmlNode $sort --> xmlXPathObjectPtr *) is native(XSLT) {*};
    method xsltCopy(xmlNode $node, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltCopyNamespace(xmlNode $elem, xmlNs $ns --> xmlNs) is native(XSLT) {*};
    method xsltCopyNamespaceList(xmlNode $node, xmlNs $cur --> xmlNs) is native(XSLT) {*};
    method xsltCopyOf(xmlNode $node, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltCopyTextString(xmlNode $target, xmlCharP $string, int32 $noescape --> xmlNode) is native(XSLT) {*};
    method xsltCreateRVT( --> xmlDoc) is native(XSLT) {*};
    method xsltDebug(xmlNode $node, xmlNode $inst, xsltElemPreComp $comp) is native(XSLT) {*};
    method xsltDefaultSortFunction(xmlNodePtr * $sorts, int32 $nbsorts) is native(XSLT) {*};
    method xsltDoSortFunction(xmlNodePtr * $sorts, int32 $nbsorts) is native(XSLT) {*};
    method xsltDocumentElem(xmlNode $node, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltElement(xmlNode $node, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltEvalAVT(Pointer $avt, xmlNode $node --> xmlCharP) is native(XSLT) {*};
    method xsltEvalAttrValueTemplate(xmlNode $inst, xmlCharP $name, xmlCharP $ns --> xmlCharP) is native(XSLT) {*};
    method xsltEvalGlobalVariables( --> int32) is native(XSLT) {*};
    method xsltEvalOneUserParam(xmlCharP $name, xmlCharP $value --> int32) is native(XSLT) {*};
    method xsltEvalTemplateString(xmlNode $contextNode, xmlNode $inst --> xmlCharP) is native(XSLT) {*};
    method xsltEvalUserParams(const char ** $params --> int32) is native(XSLT) {*};
    method xsltEvalXPathPredicate(xmlXPathCompExpr $comp, xmlNsPtr * $nsList, int32 $nsNr --> int32) is native(XSLT) {*};
    method xsltEvalXPathString(xmlXPathCompExpr $comp --> xmlCharP) is native(XSLT) {*};
    method xsltEvalXPathStringNs(xmlXPathCompExpr $comp, int32 $nsNr, xmlNsPtr * $nsList --> xmlCharP) is native(XSLT) {*};
    method xsltExtElementLookup(xmlCharP $name, xmlCharP $URI --> xsltTransformFunction) is native(XSLT) {*};
    method xsltExtensionInstructionResultFinalize( --> int32) is native(XSLT) {*};
    method xsltExtensionInstructionResultRegister(xmlXPathObject $obj --> int32) is native(XSLT) {*};
    method xsltFindDocument(xmlDoc $doc --> xsltDocument) is native(XSLT) {*};
    method xsltFindElemSpaceHandling(xmlNode $node --> int32) is native(XSLT) {*};
    method xsltFindTemplate(xmlCharP $name, xmlCharP $nameURI --> xsltTemplate) is native(XSLT) {*};
    method xsltFlagRVTs(xmlXPathObject $obj, Pointer $val --> int32) is native(XSLT) {*};
    method xsltForEach(xmlNode $contextNode, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltFreeCtxtExts() is native(XSLT) {*};
    method xsltFreeDocuments() is native(XSLT) {*};
    method xsltFreeGlobalVariables() is native(XSLT) {*};
    method xsltFreeRVTs() is native(XSLT) {*};
    method xsltFree() is native(XSLT) is symbol('xsltFreeTransformContext') {*};
    method xsltGetExtData(xmlCharP $URI --> Pointer) is native(XSLT) {*};
    method xsltGetKey(xmlCharP $name, xmlCharP $nameURI, xmlCharP $value --> xmlNodeSet) is native(XSLT) {*};
    method xsltGetNamespace(xmlNode $cur, xmlNs $ns, xmlNode $out --> xmlNs) is native(XSLT) {*};
    method xsltGetPlainNamespace(xmlNode $cur, xmlNs $ns, xmlNode $out --> xmlNs) is native(XSLT) {*};
    method xsltGetProfileInformation( --> xmlDoc) is native(XSLT) {*};
    method xsltGetSpecialNamespace(xmlNode $invocNode, xmlCharP $nsName, xmlCharP $nsPrefix, xmlNode $target --> xmlNs) is native(XSLT) {*};
    method xsltGetTemplate(xmlNode $node, xsltStylesheet $style --> xsltTemplate) is native(XSLT) {*};
    method xsltIf(xmlNode $contextNode, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltInitAllDocKeys( --> int32) is native(XSLT) {*};
    method xsltInitCtxtExts( --> int32) is native(XSLT) {*};
    method xsltInitCtxtKey(xsltDocument $idoc, xsltKeyDef $keyDef --> int32) is native(XSLT) {*};
    method xsltInitCtxtKeys(xsltDocument $idoc) is native(XSLT) {*};
    method xsltLoadDocument(xmlCharP $URI --> xsltDocument) is native(XSLT) {*};
    method xsltLocalVariablePop(int32 $limitNr, int32 $level) is native(XSLT) {*};
    method xsltLocalVariablePush(xsltStackElem $variable, int32 $level --> int32) is native(XSLT) {*};
    method xsltMatchPattern(xmlNode $node, xmlCharP $pattern, xmlDoc $ctxtdoc, xmlNode $ctxtnode --> int32) is native(XSLT) {*};
    method xsltMessage(xmlNode $node, xmlNode $inst) is native(XSLT) {*};
    method xsltNeedElemSpaceHandling( --> int32) is native(XSLT) {*};
    method xsltNewDocument(xmlDoc $doc --> xsltDocument) is native(XSLT) {*};
    method xsltNumber(xmlNode $node, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltNumberFormat(xsltNumberData $data, xmlNode $node) is native(XSLT) {*};
    method xsltParseStylesheetCallerParam(xmlNode $inst --> xsltStackElem) is native(XSLT) {*};
    method xsltParseStylesheetParam(xmlNode $cur) is native(XSLT) {*};
    method xsltParseStylesheetVariable(xmlNode $inst) is native(XSLT) {*};
    method xsltPrintError(xsltStylesheet $style, xmlNode $node) is native(XSLT) is symbol('xsltPrintErrorContext') {*};
    method xsltProcessOneNode(xmlNode $contextNode, xsltStackElem $withParams) is native(XSLT) {*};
    method xsltProcessingInstruction(xmlNode $node, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltQuoteOneUserParam(xmlCharP $name, xmlCharP $value --> int32) is native(XSLT) {*};
    method xsltQuoteUserParams(const char ** $params --> int32) is native(XSLT) {*};
    method xsltRegisterAllElement() is native(XSLT) {*};
    method xsltRegisterExtElement(xmlCharP $name, xmlCharP $URI, xsltTransformFunction $function --> int32) is native(XSLT) {*};
    method xsltRegisterExtFunction(xmlCharP $name, xmlCharP $URI, xmlXPathFunction $function --> int32) is native(XSLT) {*};
    method xsltRegisterExtras() is native(XSLT) {*};
    method xsltRegisterLocalRVT(xmlDoc $RVT --> int32) is native(XSLT) {*};
    method xsltRegisterPersistRVT(xmlDoc $RVT --> int32) is native(XSLT) {*};
    method xsltRegisterTmpRVT(xmlDoc $RVT --> int32) is native(XSLT) {*};
    method xsltReleaseRVT(xmlDoc $RVT) is native(XSLT) {*};
    method xsltSaveProfiling(FILE * $output) is native(XSLT) {*};
    method xsltSetCtxtParseOptions(int32 $options --> int32) is native(XSLT) {*};
    method xsltSetCtxtSortFunc(xsltSortFunc $handler) is native(XSLT) {*};
    method xsltSetTransformErrorFunc(Pointer $ctx, xmlGenericErrorFunc $handler) is native(XSLT) {*};
    method xsltShutdownCtxtExts() is native(XSLT) {*};
    method xsltSort(xmlNode $node, xmlNode $inst, xsltElemPreComp $comp) is native(XSLT) {*};
    method xsltTemplateProcess(xmlNode $node --> xmlNodePtr *) is native(XSLT) {*};
    method xsltTestCompMatchList(xmlNode $node, xsltCompMatch $comp --> int32) is native(XSLT) {*};
    method xsltText(xmlNode $node, xmlNode $inst, xsltElemPreComp $comp) is native(XSLT) {*};
    method xsltTransformError(xsltStylesheet $style, xmlNode $node, Str $msg, ... $...) is native(XSLT) {*};
    method xsltValueOf(xmlNode $node, xmlNode $inst, xsltElemPreComp $castedComp) is native(XSLT) {*};
    method xsltVariableLookup(xmlCharP $name, xmlCharP $ns_uri --> xmlXPathObject) is native(XSLT) {*};
}

class xsltVarInfo is repr('CStruct') {
    has xsltVarInfo $.next; # next in the list
    has xsltVarInfo $.prev;
    has int32 $.depth; # the depth in the tree
    has xmlCharP $.name;
    has xmlCharP $.nsName;
}

sub xsltFreeAVTList(Pointer $avt) is native(XSLT) is export {*};
sub xsltIsBlank(xmlCharP $str --> int32) is native(XSLT) is export {*};
sub xsltUninit() is native(XSLT) is export {*};
